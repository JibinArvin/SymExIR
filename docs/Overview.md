# LLVMSymEx

## Introduction

本文档主要是为了开发者简介LLVMSymEx项目的设计思路与细节。本文将从三个方面介绍LLVMSymEx的整体结构与细节：（1）设计目的与功能实现；（2）设计模块概述；（3）LLVMSymEx实现方法。

## 设计目的与功能实现

LLVMSymEx的产生目的是为了在静态环境下，验证BB块维度下的指令实际执行结果是否与LLVM中的指令预期执行结果相同。在LLVM IR向最终指令集相关的汇编代码生成过程中，编译器将针对特定平台对LLVM IR进行各类优化与实现，这会导致生成的汇编指令不是IR指令的一一对应，LLVMSymEx能够帮助编译器开发者验证指令转译等过程是否出现错误，辅助开发者快速验证编译器生成结果的正确性。

而由于实现的难度与验证范围当前的需求，LLVMSymEx的验证目标集中在BB块内部，即仅对同时存在一个相同的BB块内部的指令执行结果进行验证，同时由于验证信息条件的限制，所有被验证的LLVM指令都是以load指令作为开始。并且，LLVMSymEx的输入对象需要通过dependence graph验证保证内部指令的完整性，即参与分析的LLVM IR是具备内部逻辑完整性的，也就是除需要通过load加载的IR指令value对象外，所有参与验证的IR指令涉及到的对象都应由BB块内部指令通过运算产生。

综上，如果需要通过LLVMSymEx对指令执行结果进行验证，参与验证的IR指令与指令执行结果是必不可少的。

### 验证IR指令要求

所有参与验证的IR指令需要满足两个个条件，(1) 能够通过符号执行能够进行模拟验证，(2) 指令中含有的变量都能被追溯。

首先需要明确的是并不是所有的IR指令都能被验证，这主要受制于实现过程中验证计算所使用的符号执行引擎。当前的符号执行引擎能够完成运算有限，即便是当前最为流行的Z3符号执行工具能够提供的运算方法也是有限的，未能覆盖LLVM所有的计算对象，例如Function Call是执行引擎完全无法无法实现的，无法实现的原因不仅仅是Function Call自身已超过了BB块范围，也是通过符号执行对Function Call结果进行模拟的成本是巨大的。

而在LLVMSymEx能进行验证的范围中，所有参与运算的变量都需要一个确定的数据来源，也就是说，每一个变量的具体数值只有两种来源，一是来自load类指令通过配置文件加载，二是通过符号执行对LLVM IR进行模拟运算获取计算结果。这就要求在将模拟对象传入LLVMSymEx前就需要对其完备性检查，LLVMSymEx自身也会在运行期间对其进行动态的检查。

### 指令执行结果

指令执行结果将与LLVMSymEx模拟生成的结果进行对比验证，以保证两者的一致性。但受限于其基于静态实现，LLVMSymEx无法完全做到对LLVM IR的完全模拟，尤其是与内存读写相关，LLVM内置特殊类型（posion type，aggregate type）与普通函数返回值等等。
所以部分指令执行结果并不是简单作为验证结果传入，反而是作为相应的加载信息传入，并不进行相应的结果对比。同时这部分LLVM IR指令也不会参与模拟计算过程，而是直接参照LLVM IR中的类型固定为一个确定的符号执行变量。

## 设计模块

从实现的角度，我们将LLVMSymEx分为三个不同的模块，分别是:验证数据读取模块，指令模拟转换模块，结果验证模块。

验证数据读取模块，需要按照格式将预设数据读取，其中预设数据包括验证LLVM IR指令与验证数据。

指令模拟转换模块，则是指将LLVM IR转换成为符号执行引擎的相应指令，后续的结果验证都是依赖于转换后的符号执行引擎语句。

结果验证模块，获取符号执行引擎计算结果并将结果与验证值进行比较，检验结果是否一致。

## LLVMSymEx实现方法

由于需要在不真实运行程序的情况下获取指令运行的结果，LLVMSymEx选取符号执行作为最重要的实现方法。通过将LLVM IR转换成相应的符号执行引擎语句。所谓的符号执行引擎在LLVMSymEx中特指约束求解器（Constraint solver），solver能够通过添加约束对数学多个维度（实数，向量，浮点数）的问题进行运算求解，能够承担LLVMSymEx的大部分运算任务。

LLVMSymEx采取的约束求解器为[Z3](https://github.com/Z3Prover/z3)，Z3在被Microsoft提出后，获得广泛应用，其具备几个方面的优点：运算领域广，语言api种类多与运算类型实现广泛。

通过手工对LLVM IR与SMT Solver语句进行匹配，例如IR中常见的`add` operation与Z3求解器中的<code>ADD</code>或`FADD`存在对应关系，可以在合适的条件下进行transfer或者lowering。还有许多其他的例子，如LLVM IR中的`urem`也与`z3.UREM`能起到相似的作用。

在对LLVM IR指令进行转换并存储后，就能对其计算结果进行验证。而在结果验证阶段，LLVMSymEx并不不会保留长线条的计算过程，而是会在对计算结果进行验证后，将LLVM IR计算结果直接替换成应当验证的数值。这样的做法能够充分地利用验证的数据，不只能避免因为过长的计算路径带来的时间负担，同时也可以避免由于长链条的浮点计算引入越来愈大的误差。

### Float Value Tolerance

由于浮点数计算的精确结果会因为浮点数的精度，执行程序的编写与执行计算单元的架构设计而发生变化。LLVMSymEx的计算依赖SMT Solver同样会因为以上的原因而产生波动，这些波动是需要在验证浮点数过程中纳入考虑的。LLVMSymEx为其做出了两点努力，一是，在验证时将允许一定的浮点数误差；二是，在单个value在验证结束后，将其替换成一个固定的数字，阻断过长的计算链条而带来不断越来越大的计算误差。

## Reference

1. https://qemu.readthedocs.io/en/latest/devel/tracing.html