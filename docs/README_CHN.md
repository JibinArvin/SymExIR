# LLVMSymEx

## Introduction

本文档主要是为了开发者简介LLVMSymEx项目的设计思路与细节。本文将从三个方面介绍LLVMSymEx的整体结构与细节：（1）设计目的与功能实现；（2）设计模块概述；（3）LLVMSymEx实现方法。

## 设计目的与功能实现

LLVMSymEx的产生目的是为了在静态环境下，验证BB块维度下的指令实际执行结果是否与LLVM中的指令预期执行结果相同。在LLVM IR向最终指令集相关的汇编代码生成过程中，编译器将针对特定平台对LLVM IR进行各类优化与实现，这会导致生成的汇编指令不是IR指令的一一对应，LLVMSymEx能够帮助编译器开发者验证指令转译等过程是否出现错误，辅助开发者快速验证编译器生成结果的正确性。

而由于实现的难度与验证范围当前的需求，LLVMSymEx的验证目标集中在BB块内部，即仅对同时存在一个相同的BB块内部的指令执行结果进行验证，同时由于验证信息条件的限制，所有被验证的LLVM指令都是以load指令作为开始。并且，LLVMSymEx的输入对象需要通过dependence graph验证保证内部指令的完整性，即参与分析的LLVM IR是具备内部逻辑完整性的，也就是除需要通过load加载的IR指令value对象外，所有参与验证的IR指令涉及到的对象都应由BB块内部指令通过运算产生。

综上，如果需要通过LLVMSymEx对指令执行结果进行验证，参与验证的IR指令与指令执行结果是必不可少的。

### 验证IR指令要求

所有参与验证的IR指令需要满足两个个条件，(1) 能够通过符号执行能够进行模拟验证，(2) 指令中含有的变量都能被追溯。

首先需要明确的是并不是所有的IR指令都能被验证，这主要受制于实现过程中验证计算所使用的符号执行引擎。当前的符号执行引擎能够完成运算有限，即便是当前最为流行的Z3符号执行工具能够提供的运算方法也是有限的，未能覆盖LLVM所有的计算对象，例如Function Call是执行引擎完全无法无法实现的，无法实现的原因不仅仅是Function Call自身已超过了BB块范围，也是通过符号执行对Function Call结果进行模拟的成本是巨大的。

而在LLVMSymEx能进行验证的范围中，所有参与运算的变量都需要一个确定的数据来源，也就是说，每一个变量的具体数值只有两种来源，一是来自load类指令通过配置文件加载，二是通过符号执行对LLVM IR进行模拟运算获取计算结果。这就要求在将模拟对象传入LLVMSymEx前就需要对其完备性检查，LLVMSymEx自身也会在运行期间对其进行动态的检查。

### 指令执行结果

指令执行结果将与LLVMSymEx模拟生成的结果进行对比验证，以保证两者的一致性。但受限于其基于静态实现，LLVMSymEx无法完全做到对LLVM IR的完全模拟，尤其是与内存读写相关，LLVM内置特殊类型（posion type，aggregate type）与普通函数返回值等等。
所以部分指令执行结果并不是简单作为验证结果传入，反而是作为相应的加载信息传入，并不进行相应的结果对比。同时这部分LLVM IR指令也不会参与模拟计算过程，而是直接参照LLVM IR中的类型固定为一个确定的符号执行变量。

## 设计模块

从实现的角度，我们将LLVMSymEx分为三个不同的模块，分别是:验证数据读取模块，指令模拟转换模块，结果验证模块。

验证数据读取模块，需要按照格式将预设数据读取，其中预设数据包括验证LLVM IR指令与验证数据。

指令模拟转换模块，则是指将LLVM IR转换成为符号执行引擎的相应指令，后续的结果验证都是依赖于转换后的符号执行引擎语句。

结果验证模块，获取符号执行引擎计算结果并将结果与验证值进行比较，检验结果是否一致。

## LLVMSymEx实现方法

由于需要在不真实运行程序的情况下，LLVMSymEx选取符号执行作为最重要的实现方法。通过将LLVM IR转换成相应的符号执行引擎语句。所谓的符号执行引擎在LLVMSymEx中特指约束求解器（Constraint solver），solver能够通过添加约束对数学多个维度（实数，向量，浮点数）的问题进行运算求解，能够承担LLVMSymEx的大部分运算任务。

LLVMSymEx采取的约束求解器为[Z3](https://github.com/Z3Prover/z3)，Z3在被Microsoft提出后，获得广泛应用，其具备几个方面的优点：运算领域广，语言api种类多与运算类型实现广泛。
